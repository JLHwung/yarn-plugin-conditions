/* eslint-disable */
module.exports = {
name: "@yarnpkg/plugin-conditions",
factory: function (require) {
var plugin;plugin=(()=>{"use strict";var e={990:(e,t,n)=>{n.r(t),n.d(t,{default:()=>x});const r=require("@yarnpkg/core");function o(e){return e.startsWith("condition:")}function i(e){try{return function(e){if(!e.startsWith("condition:",0))throw new Error(`Expected 'condition:' at index 0 (${e})`);let t="condition:".length;a();const n=c(/[\w-]+/y);if(!n)throw new Error(`Expected an identifier at index ${t} (${e})`);a(),s("?"),a();let r=null;"("===e[t]?(r=u().trim(),a()):":"!==e[t]&&(r=l(":").trimRight()),s(":"),a();let o=null;t<e.length&&("("===e[t]?(o=u().trim(),a()):":"!==e[t]&&(o=l("#").trimRight()));let i=null;if(t<e.length&&"#"===e[t]&&(t++,i=c(/\w+/y),a()),t!==e.length)throw new Error(`Unexpected '${e[t]}' at index ${t} (${e})`);return{test:n,consequent:r,alternate:o,hash:i};function s(n){if(e[t]!==n)throw new Error(`Expected '${n}' at index ${t} (${e})`);t++}function a(){c(/\s*/y)}function c(n){n.lastIndex=t;const r=n.exec(e);return r?(t+=r[0].length,r[0]):null}function l(n){const r=t;return t=e.indexOf(n,r),-1===t&&(t=e.length),e.slice(r,t)}function u(){s("(");let n=1,r="";for(;n;){if(t===e.length)throw new Error(`Expected ')' at index ${t} (${e})`);const o=e[t];"("===o&&n++,")"===o&&n--,(")"!==o||n>0)&&(r+=o),t++}return r}}(e)}catch(t){try{const{test:t,consequent:n,alternate:o}=r.structUtils.parseRange(e).params;return{test:t,consequent:n||null,alternate:o||null}}catch(e){throw t}}}function s(e){return i(e.range)}function a(e){return i(e.reference)}function c({test:e,consequent:t,alternate:n,hash:r}){return`condition:${e}?${t||""}:${n||""}#${r||""}`}function l(e,{test:t,consequent:n,alternate:o,hash:i}){return r.structUtils.makeLocator(e,c({test:t,consequent:n,alternate:o,hash:i}))}function u(e,t,n,o,i){const s=r.structUtils.makeIdent(t.scope,`${t.name}-${n}-${i}`),a=e.configuration.get("defaultProtocol")+`${r.structUtils.stringifyIdent(t)}@${o}`;return r.structUtils.makeDescriptor(s,a)}function d(e,t,n,o){return r.hashUtils.makeHash(String(4),e,t||"-",n||"-",o?"1":"0").slice(0,6)}const p={conditions:{description:"",type:r.SettingsType.MAP,valueDefinition:{description:"",type:r.SettingsType.SHAPE,properties:{source:{description:"",type:r.SettingsType.STRING,default:"env"},default:{description:"",type:r.SettingsType.BOOLEAN,default:!1}}}}};function f(e,t){if(!e.configuration.get("conditions").has(t))throw new Error(`Unknown condition: ${t}. You must add it to your .yarnrc.yml file.`)}function g(e,t){return f(e,t),e.configuration.get("conditions").get(t).get("default")}function h(e,t){var n;f(e,t);const r=e.configuration.get("conditions").get(t),o=r.get("source"),i=r.get("default");if("env"!==o)throw new Error("The only supported configuration source is 'env'");return null!==(n=(s=process.env[t])&&"false"!==s&&"0"!==s)&&void 0!==n?n:i;var s}const m=require("@yarnpkg/fslib"),y=require("@yarnpkg/libzip");const w=["dependencies","devDependencies","peerDependencies"];const v=require("@yarnpkg/cli"),k=require("clipanion");var P=function(e,t,n,r){var o,i=arguments.length,s=i<3?t:null===r?r=Object.getOwnPropertyDescriptor(t,n):r;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,n,r);else for(var a=e.length-1;a>=0;a--)(o=e[a])&&(s=(i<3?o(s):i>3?o(t,n,s):o(t,n))||s);return i>3&&s&&Object.defineProperty(t,n,s),s};class j extends v.BaseCommand{async execute(){if(this.false&&this.true)throw new Error("You can either specify --true or --false");const{project:e,workspace:t,cache:n,configuration:o}=await this.getRoot();f(e,this.condition);const i=!this.false&&(!!this.true||h(e,this.condition));for(const n of this.nestedWorkspaces(t,e))this.materializeCondition(i,n);const s=await r.StreamReport.start({configuration:o,stdout:this.context.stdout,includeLogs:!0},async t=>{await e.resolveEverything({cache:n,report:t})});if(s.hasErrors())return s.exitCode();await e.persist()}*nestedWorkspaces(e,t){yield e;for(const n of e.workspacesCwds){const e=t.workspacesByCwd.get(n);e&&(yield*this.nestedWorkspaces(e,t))}}materializeCondition(e,t){for(const n of w){const i=t.manifest.getForScope(n).values();for(const a of i){if(!o(a.range))continue;const{test:i,consequent:c,alternate:l}=s(a);if(i!==this.condition)continue;const u=e?c:l;u?t.manifest[n].set(a.identHash,r.structUtils.makeDescriptor(a,u)):t.manifest[n].delete(a.identHash)}}}async getRoot(){const e=await r.Configuration.find(this.context.cwd,this.context.plugins),[{project:t,workspace:n},o]=await Promise.all([r.Project.find(e,this.context.cwd),r.Cache.find(e,{immutable:!0})]);return{configuration:e,project:t,workspace:n,cache:o}}}j.usage=k.Command.Usage({description:"Evaluate and replace a condition in package.json files",details:"\n      This command will replace all the occurrences of `<condition>` in the current workspace and in nested workspaces.\n\n      The value of the condition (`true` or `false`) is based on the following sources, in descending priority order:\n\n      - the `--true` or `--false` option;\n      - the `<condition>` environment variable;\n      - the default value specified in the Yarn configuration;\n      - `false` by default.\n    "}),P([k.Command.String({required:!0})],j.prototype,"condition",void 0),P([k.Command.Boolean("--true")],j.prototype,"true",void 0),P([k.Command.Boolean("--false")],j.prototype,"false",void 0),P([k.Command.Path("condition","materialize")],j.prototype,"execute",null);const x={configuration:p,commands:[j],fetchers:[class{supports(e){return o(e.reference)}getLocalPath(){return null}async fetch(e,t){const n=t.checksums.get(e.locatorHash)||null,[o,i,s]=await t.cache.fetchPackageFromCache(e,n,{onHit:()=>t.report.reportCacheHit(e),onMiss:()=>t.report.reportCacheMiss(e,r.structUtils.prettyLocator(t.project.configuration,e)+" can't be found in the cache and will be fetched from the disk"),loader:()=>this.generateConditionPackage(e,t),skipIntegrityCheck:t.skipIntegrityCheck});return{packageFs:o,releaseFs:i,prefixPath:r.structUtils.getIdentVendorPath(e),localPath:this.getLocalPath(),checksum:s}}async generateConditionPackage(e,t){const{test:n,consequent:o,alternate:i}=a(e),s=g(t.project,n),c=d(n,o,i,s),l=(o,i)=>{if(null==o)return{dependency:null,specifier:JSON.stringify("ASSERT: Missing dependency")};const s=u(t.project,e,n,o,i),a=r.structUtils.stringifyIdent(s);return{dependency:{[a]:s.range},specifier:JSON.stringify(a)}},p=l(o,!0),f=l(i,!1);return async function(e,t,n,o){const[i,s]=await Promise.all([m.xfs.mktempPromise(),(0,y.getLibzipPromise)()]),a=m.ppath.join(i,"condition.zip"),c=r.structUtils.getIdentVendorPath(e),l=new m.ZipFS(a,{libzip:s,create:!0,level:t.configuration.get("compressionLevel")});return await l.mkdirpPromise(c),await Promise.all([l.writeJsonPromise(m.ppath.join(c,"package.json"),n),l.writeFilePromise(m.ppath.join(c,"index.js"),o)]),await Promise.all(l.getAllFiles().map(e=>l.utimesPromise(e,15805116e5,15805116e5))),l}(e,t.project,{version:"0.0.0-condition-"+c,dependencies:{...p.dependency,...f.dependency}},`// env vars from the cli are always strings, so !!ENV_VAR returns true for "false"\nfunction bool(value) {\n  if (value == null) return ${s};\n  return value && value !== "false" && value !== "0";\n}\nmodule.exports = bool(process.env[${JSON.stringify(n)}])\n  ? require(${p.specifier})\n  : require(${f.specifier});\n`)}}],resolvers:[class{supportsDescriptor(e){return o(e.range)}supportsLocator(e){return o(e.reference)}shouldPersistResolution(){return!1}bindDescriptor(e){return e}getResolutionDependencies(e,t){const{test:n,consequent:r,alternate:o}=s(e);return[r&&u(t.project,e,n,r,!0),o&&u(t.project,e,n,o,!1)].filter(Boolean)}async getCandidates(e,t,n){const{test:r,consequent:o,alternate:i}=s(e);return[l(e,{test:r,consequent:o,alternate:i,hash:d(r,o,i,g(n.project,r))})]}async getSatisfying(){return null}async resolve(e,t){const{test:n,consequent:o,alternate:i}=a(e),s=d(n,o,i,g(t.project,n)),c=o&&u(t.project,e,n,o,!0),l=i&&u(t.project,e,n,i,!1);return{...e,version:"0.0.0-condition-"+s,languageName:t.project.configuration.get("defaultLanguageName"),linkType:r.LinkType.HARD,dependencies:new Map([o&&[c.identHash,c],i&&[l.identHash,l]].filter(Boolean)),peerDependencies:new Map,dependenciesMeta:new Map,peerDependenciesMeta:new Map,bin:null}}}],hooks:{beforeWorkspacePacking:async function(e,t){var n;const{project:i}=e;let a=!1;for(const c of w){const l=e.manifest.getForScope(c).values();for(const u of l){if(!o(u.range))continue;const{test:l,consequent:d,alternate:p}=s(u),f=h(i,l)?d:p,g=r.structUtils.stringifyIdent(u),m="dependencies"===c&&!t.dependencies[g]&&(null===(n=t.optionalDependencies)||void 0===n?void 0:n[g])?"optionalDependencies":c;f?(t[m][g]=f,e.manifest.raw[m][g]=f,e.manifest[c].set(u.identHash,r.structUtils.makeDescriptor(u,f))):(delete t[m][g],delete e.manifest.raw[m][g],e.manifest[c].delete(u.identHash)),a=!0}}a&&await e.project.configuration.triggerHook(e=>e.beforeWorkspacePacking,e,t)}}}}},t={};function n(r){if(t[r])return t[r].exports;var o=t[r]={exports:{}};return e[r](o,o.exports,n),o.exports}return n.d=(e,t)=>{for(var r in t)n.o(t,r)&&!n.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),n.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n(990)})();
return plugin;
}
};