/* eslint-disable */
module.exports = {
name: "@yarnpkg/plugin-conditions",
factory: function (require) {
var plugin;plugin=(()=>{"use strict";var e={901:(e,t,n)=>{n.r(t),n.d(t,{default:()=>k});const r=require("@yarnpkg/core");function o(e){return e.startsWith("condition:")}function s(e){const t=e.match(/^condition:\s*(?<test>\w+)\s*\?\s*(?<consequent>[^\s:]*)\s*:\s*(?<alternate>[^\s:#]*)\s*(?:#(.*))?$/);let n;n=null!==t?t.groups:r.structUtils.parseRange(e).params;const{test:o,consequent:s,alternate:i}=n;return{test:o,consequent:s||null,alternate:i||null}}function i(e){return s(e.range)}function a(e){return s(e.reference)}function c(e,t,n,o){if(!o)return null;const s=r.structUtils.makeIdent("",`${n}-${e}-${t}`);return r.structUtils.makeDescriptor(s,`npm:${n}@${o}`)}function u({test:e,consequent:t,alternate:n,hash:r}){return`condition:${e}?${t||""}:${n||""}#${r||""}`}function l(e,{test:t,consequent:n,alternate:o,hash:s}){return r.structUtils.makeLocator(e,u({test:t,consequent:n,alternate:o,hash:s}))}function p(e,t,n,o){return r.hashUtils.makeHash(String(2),e,t||"-",n||"-",o?"1":"0").slice(0,6)}const f={conditions:{description:"",type:r.SettingsType.MAP,valueDefinition:{description:"",type:r.SettingsType.SHAPE,properties:{source:{description:"",type:r.SettingsType.STRING,default:"env"},default:{description:"",type:r.SettingsType.BOOLEAN,default:!1}}}}};function d(e,t){if(!e.configuration.get("conditions").has(t))throw new Error(`Unknown condition: ${t}. You must add it to your .yarnrc.yml file.`)}function g(e,t){return d(e,t),e.configuration.get("conditions").get(t).get("default")}function h(e,t){var n;d(e,t);const r=e.configuration.get("conditions").get(t),o=r.get("source"),s=r.get("default");if("env"!==o)throw new Error("The only supported configuration source is 'env'");return null!==(n=(i=process.env[t])&&"false"!==i&&"0"!==i)&&void 0!==n?n:s;var i}const m=require("@yarnpkg/fslib"),y=require("@yarnpkg/libzip");const v=["dependencies","devDependencies","peerDependencies"];const k={configuration:f,fetchers:[class{supports(e){return o(e.reference)}getLocalPath(){return null}async fetch(e,t){const n=t.checksums.get(e.locatorHash)||null,[o,s,i]=await t.cache.fetchPackageFromCache(e,n,{onHit:()=>t.report.reportCacheHit(e),onMiss:()=>t.report.reportCacheMiss(e,r.structUtils.prettyLocator(t.project.configuration,e)+" can't be found in the cache and will be fetched from the disk"),loader:()=>this.generateConditionPackage(e,t),skipIntegrityCheck:t.skipIntegrityCheck});return{packageFs:o,releaseFs:s,prefixPath:r.structUtils.getIdentVendorPath(e),localPath:this.getLocalPath(),checksum:i}}async generateConditionPackage(e,t){const{test:n,consequent:o,alternate:s}=a(e),i=g(t.project,n),{name:c}=e,u=p(n,o,s,i),[l,f]=await Promise.all([m.xfs.mktempPromise(),(0,y.getLibzipPromise)()]),d=m.ppath.join(l,"condition.zip"),h=r.structUtils.getIdentVendorPath(e),v=new m.ZipFS(d,{libzip:f,create:!0,level:t.project.configuration.get("compressionLevel")});return await v.mkdirpPromise(h),await v.writeJsonPromise(m.ppath.join(h,"package.json"),{version:"0.0.0-condition-"+u,dependencies:{[`${c}-${n}-true`]:o,[`${c}-${n}-false`]:s}}),await v.writeFilePromise(m.ppath.join(h,"index.js"),`// env vars from the cli are always strings, so !!ENV_VAR returns true for "false"\nfunction bool(value) {\n  if (value == null) return ${i};\n  return value && value !== "false" && value !== "0";\n}\n\nmodule.exports = bool(process.env[${JSON.stringify(n)}])\n  ? require(${JSON.stringify(`${c}-${n}-true`)})\n  : require(${JSON.stringify(`${c}-${n}-false`)});\n`),await Promise.all(v.getAllFiles().map(e=>v.utimesPromise(e,15805116e5,15805116e5))),v}}],resolvers:[class{supportsDescriptor(e){return o(e.range)}supportsLocator(e){return o(e.reference)}shouldPersistResolution(){return!1}bindDescriptor(e){return e}getResolutionDependencies(e){const{test:t,consequent:n,alternate:r}=i(e);return[c(t,!0,e.name,n),c(t,!1,e.name,r)].filter(Boolean)}async getCandidates(e,t,n){const{test:r,consequent:o,alternate:s}=i(e);return[l(e,{test:r,consequent:o,alternate:s,hash:p(r,o,s,g(n.project,r))})]}async getSatisfying(){return null}async resolve(e,t){const{test:n,consequent:o,alternate:s}=a(e),i=p(n,o,s,g(t.project,n)),u=c(n,!0,e.name,o),l=c(n,!1,e.name,s);return{...e,version:"0.0.0-condition-"+i,languageName:t.project.configuration.get("defaultLanguageName"),linkType:r.LinkType.HARD,dependencies:new Map([u&&[u.identHash,u],l&&[l.identHash,l]].filter(Boolean)),peerDependencies:new Map,dependenciesMeta:new Map,peerDependenciesMeta:new Map,bin:null}}}],hooks:{beforeWorkspacePacking:function(e,t){const{project:n}=e;for(const s of v){const a=e.manifest.getForScope(s).values();for(const e of a){if(!o(e.range))continue;const{test:a,consequent:c,alternate:u}=i(e),l=h(n,a)?c:u,p=r.structUtils.stringifyIdent(e);l?t[s][p]=l:delete t[s][p]}}}}}}},t={};function n(r){if(t[r])return t[r].exports;var o=t[r]={exports:{}};return e[r](o,o.exports,n),o.exports}return n.d=(e,t)=>{for(var r in t)n.o(t,r)&&!n.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),n.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n(901)})();
return plugin;
}
};