/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@yarnpkg/plugin-conditions",
factory: function (require) {
var plugin=(()=>{var ie=Object.create;var R=Object.defineProperty;var re=Object.getOwnPropertyDescriptor;var se=Object.getOwnPropertyNames;var ae=Object.getPrototypeOf,ce=Object.prototype.hasOwnProperty;var g=(t=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(t,{get:(n,e)=>(typeof require<"u"?require:n)[e]}):t)(function(t){if(typeof require<"u")return require.apply(this,arguments);throw new Error('Dynamic require of "'+t+'" is not supported')});var le=(t,n)=>{for(var e in n)R(t,e,{get:n[e],enumerable:!0})},B=(t,n,e,i)=>{if(n&&typeof n=="object"||typeof n=="function")for(let o of se(n))!ce.call(t,o)&&o!==e&&R(t,o,{get:()=>n[o],enumerable:!(i=re(n,o))||i.enumerable});return t};var pe=(t,n,e)=>(e=t!=null?ie(ae(t)):{},B(n||!t||!t.__esModule?R(e,"default",{value:t,enumerable:!0}):e,t)),de=t=>B(R({},"__esModule",{value:!0}),t);var ke={};le(ke,{default:()=>ye});var N=g("@yarnpkg/core");var x=g("@yarnpkg/core");function M(t){let n="condition:";if(!t.startsWith(n,0))throw new Error(`Expected 'condition:' at index 0 (${t})`);let e=n.length;p();let i=d(/[\w-]+/y);if(!i)throw new Error(`Expected an identifier at index ${e} (${t})`);p(),l("?"),p();let o=null;t[e]==="("?o=u().trim()||null:t[e]!==":"&&(o=d(/[^(:]+/y)?.trimRight()||null),l(":"),p();let r=null;e<t.length&&(t[e]==="("&&!t.startsWith("esm:",e+1)?r=u().trim()||null:t[e]!==":"&&(r=d(/[^(#]+/y)?.trimRight()||null));let s=C("esm"),a=C("peer");!s&&a&&(s=C("esm"));let c=null;if(e<t.length&&t[e]==="#"&&(e++,c=d(/\w+/y),p()),e!==t.length)throw new Error(`Unexpected '${t[e]}' at index ${e} (${t})`);return{test:i,consequent:o,alternate:r,esmExports:s,peers:a,hash:c};function l(f){if(t[e]!==f)throw new Error(`Expected '${f}' at index ${e} (${t})`);e++}function p(){d(/\s*/y)}function d(f){f.lastIndex=e;let m=f.exec(t);return m?(e+=m[0].length,m[0]):null}function u(){l("(");let f=1,m="";for(;f;){if(e===t.length)throw new Error(`Expected ')' at index ${e} (${t})`);let y=t[e];y==="("&&f++,y===")"&&f--,(y!==")"||f>0)&&(m+=y),e++}return p(),m}function C(f){if(e<t.length&&t.startsWith(`(${f}:`,e)){let m=u().slice(f.length+1).trim();if(m)return m.split(",").map(y=>y.trim())}return null}}var S=["dependencies","devDependencies","peerDependencies"];function k(t){return t.startsWith("condition:")}function Q(t){try{return M(t)}catch(n){try{let{test:e,consequent:i,alternate:o,esmExports:r,peers:s}=x.structUtils.parseRange(t).params;return{test:e,consequent:i||null,alternate:o||null,esmExports:r||null,peers:s||null}}catch{throw n}}}function j(t){return Q(t.range)}function q(t){return Q(t.reference)}function fe({test:t,consequent:n,alternate:e,esmExports:i,peers:o,hash:r}){let s=`condition:${t}?`;return n&&(s+=n),s+=":",e&&(s+=e),i&&(s+=`(esm:${i.join(",")})`),o&&(s+=`(peer:${o.join(",")})`),r&&(s+=`#${r}`),s}function z(t,{test:n,consequent:e,alternate:i,esmExports:o,peers:r,hash:s}){return x.structUtils.makeLocator(t,fe({test:n,consequent:e,alternate:i,esmExports:o,peers:r,hash:s}))}function v(t,n,e,i,o){let r=x.structUtils.makeIdent(n.scope,`${n.name}-${e}-${o}`),s=t.configuration.get("defaultProtocol")+`${x.structUtils.stringifyIdent(n)}@${i}`;return x.structUtils.makeDescriptor(r,s)}function b(t,n,e,i,o,r){return x.hashUtils.makeHash(String(11),t,n||"-",e||"-",i?.join(",")||"-",o?.join(",")||"-",r?"1":"0").slice(0,6)}var O=g("@yarnpkg/core"),K={conditions:{description:"",type:O.SettingsType.MAP,valueDefinition:{description:"",type:O.SettingsType.SHAPE,properties:{source:{description:"",type:O.SettingsType.STRING,default:"env"},default:{description:"",type:O.SettingsType.BOOLEAN,default:!1}}}}};function T(t,n){if(!t.configuration.get("conditions").has(n))throw new Error(`Unknown condition: ${n}. You must add it to your .yarnrc.yml file.`)}function L(t,n){return T(t,n),t.configuration.get("conditions").get(n).get("default")}function H(t,n){T(t,n);let e=t.configuration.get("conditions").get(n),i=e.get("source"),o=e.get("default");if(i!=="env")throw new Error("The only supported configuration source is 'env'");return me(process.env[n])??o}function me(t){return t&&t!=="false"&&t!=="0"}var I=class{supportsDescriptor(n){return k(n.range)}supportsLocator(n){return k(n.reference)}shouldPersistResolution(){return!1}bindDescriptor(n){return n}getResolutionDependencies(n,e){let{test:i,consequent:o,alternate:r,esmExports:s}=j(n);return[o&&v(e.project,n,i,o,!0),r&&v(e.project,n,i,r,!1)].filter(Boolean)}async getCandidates(n,e,i){let{test:o,consequent:r,alternate:s,esmExports:a,peers:c}=j(n),l=b(o,r,s,a,c,L(i.project,o));return[z(n,{test:o,consequent:r,alternate:s,esmExports:a,peers:c,hash:l})]}async getSatisfying(){return null}async resolve(n,e){let{test:i,consequent:o,alternate:r,esmExports:s,peers:a}=q(n),c=b(i,o,r,s,a,L(e.project,i)),l=o&&v(e.project,n,i,o,!0),p=r&&v(e.project,n,i,r,!1);return{...n,version:`0.0.0-condition-${c}`,languageName:e.project.configuration.get("defaultLanguageName"),linkType:N.LinkType.HARD,dependencies:new Map([o&&[l.identHash,l],r&&[p.identHash,p]].filter(Boolean)),peerDependencies:new Map((a||[]).map(d=>{let u=N.structUtils.parseDescriptor(`${d}@*`);return[u.identHash,u]})),dependenciesMeta:new Map,peerDependenciesMeta:new Map,bin:null}}};var V=g("@yarnpkg/core");var Z=g("@yarnpkg/core"),E=g("@yarnpkg/fslib"),W=g("@yarnpkg/libzip"),G=15805116e5;async function X(t,n,e,i,o){let[r,s]=await Promise.all([E.xfs.mktempPromise(),(0,W.getLibzipPromise)()]),a=E.ppath.join(r,"condition.zip"),c=Z.structUtils.getIdentVendorPath(t),l=new W.ZipFS(a,{libzip:s,create:!0,level:n.configuration.get("compressionLevel")});return await l.mkdirpPromise(c),await Promise.all([l.writeJsonPromise(E.ppath.join(c,"package.json"),e),l.writeFilePromise(E.ppath.join(c,"index.js"),i),o&&l.writeFilePromise(E.ppath.join(c,"index.mjs"),o)]),await Promise.all(l.getAllFiles().map(p=>l.utimesPromise(p,G,G))),l}var _=class{supports(n){return k(n.reference)}getLocalPath(){return null}async fetch(n,e){let i=e.checksums.get(n.locatorHash)||null,[o,r,s]=await e.cache.fetchPackageFromCache(n,i,{onHit:()=>e.report.reportCacheHit(n),onMiss:()=>e.report.reportCacheMiss(n,`${V.structUtils.prettyLocator(e.project.configuration,n)} can't be found in the cache and will be fetched from the disk`),loader:()=>this.generateConditionPackage(n,e),skipIntegrityCheck:e.skipIntegrityCheck});return{packageFs:o,releaseFs:r,prefixPath:V.structUtils.getIdentVendorPath(n),localPath:this.getLocalPath(),checksum:s}}async generateConditionPackage(n,e){let{test:i,consequent:o,alternate:r,esmExports:s,peers:a}=q(n),c=L(e.project,i),l=b(i,o,r,s,a,c),p=(P,U)=>{if(P==null)return{dependency:null,require:"null",esmHeader:"",imported:"{ __proto__: null }"};let D=v(e.project,n,i,P,U),A=V.structUtils.stringifyIdent(D),Y=`if_${U}`;return{dependency:{[A]:D.range},require:`require(${JSON.stringify(A)})`,esmHeader:`import * as ${Y} from ${JSON.stringify(A)};`,imported:Y}},d=p(o,!0),u=p(r,!1),C={version:`0.0.0-condition-${l}`,dependencies:{...d.dependency,...u.dependency},...s&&{exports:{require:"./index.js",default:"./index.mjs"}},...a&&{peerDependencies:Object.fromEntries(a.map(P=>[P,"*"]))}},f=`// env vars from the cli are always strings, so !!ENV_VAR returns true for "false"
function bool(value) {
  if (value == null) return ${c};
  return value && value !== "false" && value !== "0";
}
`,m=`${f}
module.exports = bool(process.env[${JSON.stringify(i)}])
  ? ${d.require}
  : ${u.require};
`,y=null;if(s){m+=`0 && (${s.map(D=>`exports.${D} = `).join("")} 0);`;let P=!1,U=[];for(let D of s)D==="default"?P=!0:U.push(D);y=`${f}
${d.esmHeader}
${u.esmHeader}

export const { ${U.join(", ")} } = bool(process.env[${JSON.stringify(i)}]) ? ${d.imported} : ${u.imported};
${P&&`export default (bool(process.env[${JSON.stringify(i)}]) ? ${d.imported} : ${u.imported}).default;`}
`}return X(n,e.project,C,m,y)}};var J=g("@yarnpkg/core");var ge=Function.call.bind(Object.prototype.hasOwnProperty);async function ee(t,n){let{project:e}=t,i=!1;for(let o of S){let r=t.manifest.getForScope(o).values();for(let s of r){if(!k(s.range))continue;let{test:a,consequent:c,alternate:l}=j(s),p=H(e,a)?c:l,d=J.structUtils.stringifyIdent(s),u=o==="dependencies"&&!n.dependencies[d]&&n.optionalDependencies?.[d]?"optionalDependencies":o;p?(n[u][d]=p,t.manifest.raw[u][d]=p,t.manifest[o].set(s.identHash,J.structUtils.makeDescriptor(s,p))):(delete n[u][d],delete t.manifest.raw[u][d],t.manifest[o].delete(s.identHash)),i=!0}}if(ge(n,"conditions")){i=!0;let o=n.conditions;for(let[r,[s,a]]of Object.entries(o)){let c=H(e,r)?s:a;if(c)for(let[l,p]of Object.entries(c))p===null?delete n[l]:n[l]=p}delete n.conditions}i&&await t.project.configuration.triggerHook(o=>o.beforeWorkspacePacking,t,n)}var h=g("@yarnpkg/core"),te=g("@yarnpkg/cli"),w=g("clipanion"),ne=pe(g("typanion"));var he=Function.call.bind(Object.prototype.hasOwnProperty),oe=(t,n,...e)=>he(t,n)&&(e.length===0||oe(t[n],...e)),$=class extends te.BaseCommand{constructor(){super(...arguments);this.condition=w.Option.String({required:!0});this.true=w.Option.Boolean("--true",!1);this.false=w.Option.Boolean("--false",!1)}async execute(){let{project:e,workspace:i,cache:o,configuration:r}=await this.getRoot();T(e,this.condition);let s=this.false?!1:this.true?!0:H(e,this.condition);for(let c of this.nestedWorkspaces(i,e))this.materializeCondition(s,c);let a=await h.StreamReport.start({configuration:r,stdout:this.context.stdout,includeLogs:!0},async c=>{await e.resolveEverything({cache:o,report:c})});if(a.hasErrors())return a.exitCode();await e.persist()}*nestedWorkspaces(e,i){yield e;for(let o of e.workspacesCwds){let r=i.workspacesByCwd.get(o);r&&(yield*this.nestedWorkspaces(r,i))}}materializeCondition(e,i){for(let r of S){let s=i.manifest.getForScope(r).values();for(let a of s){if(!k(a.range))continue;let{test:c,consequent:l,alternate:p}=j(a);if(c!==this.condition)continue;let d=e?l:p;d?i.manifest[r].set(a.identHash,h.structUtils.makeDescriptor(a,d)):i.manifest[r].delete(a.identHash)}}let o=i.manifest.raw;if(oe(o,"conditions",this.condition)){let[r,s]=o.conditions[this.condition],a=e?r:s;if(a)for(let[c,l]of Object.entries(a))l===null?delete o[c]:o[c]=l;Object.keys(o.conditions).length===1?delete o.conditions:delete o.conditions[this.condition]}}async getRoot(){let e=await h.Configuration.find(this.context.cwd,this.context.plugins),[{project:i,workspace:o},r]=await Promise.all([h.Project.find(e,this.context.cwd),h.Cache.find(e,{immutable:!0})]);return{configuration:e,project:i,workspace:o,cache:r}}};$.paths=[["condition","materialize"]],$.usage=w.Command.Usage({description:"Evaluate and replace a condition in package.json files",details:"\n      This command will replace all the occurrences of `<condition>` in the current workspace and in nested workspaces.\n\n      The value of the condition (`true` or `false`) is based on the following sources, in descending priority order:\n\n      - the `--true` or `--false` option;\n      - the `<condition>` environment variable;\n      - the default value specified in the Yarn configuration;\n      - `false` by default.\n    "}),$.schema=[ne.hasMutuallyExclusiveKeys(["true","false"])];var ye={configuration:K,commands:[$],fetchers:[_],resolvers:[I],hooks:{beforeWorkspacePacking:ee}};return de(ke);})();
return plugin;
}
};
