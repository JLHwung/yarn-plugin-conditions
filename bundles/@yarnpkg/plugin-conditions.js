/* eslint-disable */
module.exports = {
name: "@yarnpkg/plugin-conditions",
factory: function (require) {
var plugin;plugin=(()=>{"use strict";var e={952:(e,t,n)=>{n.r(t),n.d(t,{default:()=>k});const r=require("@yarnpkg/core");function o(e){return e.startsWith("condition:")}function s(e){const t=e.match(/^condition:\s*(?<test>\w+)\s*\?\s*(?<consequent>[^\s:]*)\s*:\s*(?<alternate>[^\s:#]*)\s*(?:#(.*))?$/);let n;n=null!==t?t.groups:r.structUtils.parseRange(e).params;const{test:o,consequent:s,alternate:i}=n;return{test:o,consequent:s||null,alternate:i||null}}function i(e){return s(e.range)}function a(e){return s(e.reference)}function c({test:e,consequent:t,alternate:n,hash:r}){return`condition:${e}?${t||""}:${n||""}#${r||""}`}function u(e,{test:t,consequent:n,alternate:o,hash:s}){return r.structUtils.makeLocator(e,c({test:t,consequent:n,alternate:o,hash:s}))}function l(e,t,n,o,s){const i=r.structUtils.makeIdent(t.scope,`${t.name}-${n}-${s}`),a=e.configuration.get("defaultProtocol")+`${r.structUtils.stringifyIdent(t)}@${o}`;return r.structUtils.makeDescriptor(i,a)}function p(e,t,n,o){return r.hashUtils.makeHash(String(3),e,t||"-",n||"-",o?"1":"0").slice(0,6)}const f={conditions:{description:"",type:r.SettingsType.MAP,valueDefinition:{description:"",type:r.SettingsType.SHAPE,properties:{source:{description:"",type:r.SettingsType.STRING,default:"env"},default:{description:"",type:r.SettingsType.BOOLEAN,default:!1}}}}};function d(e,t){if(!e.configuration.get("conditions").has(t))throw new Error(`Unknown condition: ${t}. You must add it to your .yarnrc.yml file.`)}function g(e,t){return d(e,t),e.configuration.get("conditions").get(t).get("default")}function h(e,t){var n;d(e,t);const r=e.configuration.get("conditions").get(t),o=r.get("source"),s=r.get("default");if("env"!==o)throw new Error("The only supported configuration source is 'env'");return null!==(n=(i=process.env[t])&&"false"!==i&&"0"!==i)&&void 0!==n?n:s;var i}const y=require("@yarnpkg/fslib"),m=require("@yarnpkg/libzip");const v=["dependencies","devDependencies","peerDependencies"];const k={configuration:f,fetchers:[class{supports(e){return o(e.reference)}getLocalPath(){return null}async fetch(e,t){const n=t.checksums.get(e.locatorHash)||null,[o,s,i]=await t.cache.fetchPackageFromCache(e,n,{onHit:()=>t.report.reportCacheHit(e),onMiss:()=>t.report.reportCacheMiss(e,r.structUtils.prettyLocator(t.project.configuration,e)+" can't be found in the cache and will be fetched from the disk"),loader:()=>this.generateConditionPackage(e,t),skipIntegrityCheck:t.skipIntegrityCheck});return{packageFs:o,releaseFs:s,prefixPath:r.structUtils.getIdentVendorPath(e),localPath:this.getLocalPath(),checksum:i}}async generateConditionPackage(e,t){const{test:n,consequent:o,alternate:s}=a(e),i=g(t.project,n),c=p(n,o,s,i),u=o&&l(t.project,e,n,o,!0),f=s&&l(t.project,e,n,s,!1),d=r.structUtils.stringifyIdent(u),h=r.structUtils.stringifyIdent(f);return async function(e,t,n,o){const[s,i]=await Promise.all([y.xfs.mktempPromise(),(0,m.getLibzipPromise)()]),a=y.ppath.join(s,"condition.zip"),c=r.structUtils.getIdentVendorPath(e),u=new y.ZipFS(a,{libzip:i,create:!0,level:t.configuration.get("compressionLevel")});return await u.mkdirpPromise(c),await Promise.all([u.writeJsonPromise(y.ppath.join(c,"package.json"),n),u.writeFilePromise(y.ppath.join(c,"index.js"),o)]),await Promise.all(u.getAllFiles().map(e=>u.utimesPromise(e,15805116e5,15805116e5))),u}(e,t.project,{version:"0.0.0-condition-"+c,dependencies:{[d]:u.range,[h]:f.range}},`// env vars from the cli are always strings, so !!ENV_VAR returns true for "false"\nfunction bool(value) {\n  if (value == null) return ${i};\n  return value && value !== "false" && value !== "0";\n}\nmodule.exports = bool(process.env[${JSON.stringify(n)}])\n  ? require(${JSON.stringify(d)})\n  : require(${JSON.stringify(h)});\n`)}}],resolvers:[class{supportsDescriptor(e){return o(e.range)}supportsLocator(e){return o(e.reference)}shouldPersistResolution(){return!1}bindDescriptor(e){return e}getResolutionDependencies(e,t){const{test:n,consequent:r,alternate:o}=i(e);return[r&&l(t.project,e,n,r,!0),o&&l(t.project,e,n,o,!1)].filter(Boolean)}async getCandidates(e,t,n){const{test:r,consequent:o,alternate:s}=i(e);return[u(e,{test:r,consequent:o,alternate:s,hash:p(r,o,s,g(n.project,r))})]}async getSatisfying(){return null}async resolve(e,t){const{test:n,consequent:o,alternate:s}=a(e),i=p(n,o,s,g(t.project,n)),c=o&&l(t.project,e,n,o,!0),u=s&&l(t.project,e,n,s,!1);return{...e,version:"0.0.0-condition-"+i,languageName:t.project.configuration.get("defaultLanguageName"),linkType:r.LinkType.HARD,dependencies:new Map([o&&[c.identHash,c],s&&[u.identHash,u]].filter(Boolean)),peerDependencies:new Map,dependenciesMeta:new Map,peerDependenciesMeta:new Map,bin:null}}}],hooks:{beforeWorkspacePacking:function(e,t){const{project:n}=e;for(const s of v){const a=e.manifest.getForScope(s).values();for(const e of a){if(!o(e.range))continue;const{test:a,consequent:c,alternate:u}=i(e),l=h(n,a)?c:u,p=r.structUtils.stringifyIdent(e);l?t[s][p]=l:delete t[s][p]}}}}}}},t={};function n(r){if(t[r])return t[r].exports;var o=t[r]={exports:{}};return e[r](o,o.exports,n),o.exports}return n.d=(e,t)=>{for(var r in t)n.o(t,r)&&!n.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),n.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n(952)})();
return plugin;
}
};